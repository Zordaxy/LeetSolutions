// 200. Number of Islands
// Given an m x n 2d grid map of '1's (land) and '0's (water), return the number of islands.
// An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.

/**
 * @param {character[][]} grid
 * @return {number}
 */
var numIslands = function(grid) {
    let count = 0;
    for (let i = 0; i < grid.length; i++) {
        for(let j = 0; j < grid[0].length; j++) {
            if (grid[i][j] === "1") {
                count++;
                dfs(grid, i, j);
            }
        }
    }

    return count;
};

function dfs(grid, i, j) {
    let queue = [];
    queue.push([i, j]);
    grid[i][j] = 0;

    while (queue.length > 0) {
        let size = queue.length;
        for (let k = 0; k < size; k++) {

            let [y, x] = queue.shift();
            if (grid[y - 1] && grid[y - 1][x] === "1") {
                queue.push([y - 1, x]);
                grid[y - 1][x] = 0;
            }
            if (grid[y + 1] && grid[y + 1][x] === "1") {
                queue.push([y + 1, x]);
                grid[y + 1][x] = 0;
            }
            if (grid[y][x - 1] === "1") {
                queue.push([y, x - 1]);
                grid[y][x - 1] = 0;
            }
            if (grid[y][x + 1] === "1") {
                queue.push([y, x + 1]);
                grid[y][x + 1] = 0;
            }
        }
    }
}

// more concise:
// public class Solution {
//     int y;          // The height of the given grid
//     int x;          // The width of the given grid
//     char[][] g;     // The given grid, stored to reduce recursion memory usage
    
//     public int numIslands(char[][] grid) {
//         g = grid;
//         int c = 0;
//         y = g.length;
//         if (y == 0) return 0;
//         x = g[0].length;
        
//         for (int i = 0; i < y; i++) {
//             for (int j = 0; j < x; j++) {
//                 if (g[i][j] == '1') {
//                     dfs(i, j);
//                     c++;
//                 }
//             }
//         }
//         return c;
//     }
    
//     private void dfs(int i, int j) {
//         if (i < 0 || i >= y || j < 0 || j >= x || g[i][j] != '1') return;
//         g[i][j] = '0';
//         dfs(i + 1, j);
//         dfs(i - 1, j);
//         dfs(i, j + 1);
//         dfs(i, j - 1);
//     }
// }

// let grid = [["1","1","1","1","0"],["1","1","0","1","0"],["1","1","0","0","0"],["0","0","0","0","0"]];
let grid = [
    ["1", "1", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "0", "1", "1"],
    ["0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "1", "1", "1", "1", "0"],
    ["1", "0", "1", "1", "1", "0", "0", "1", "1", "0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
    ["1", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
    ["1", "0", "0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
    ["1", "0", "1", "1", "1", "1", "1", "1", "0", "1", "1", "1", "0", "1", "1", "1", "0", "1", "1", "1"],
    ["0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "1", "0", "1", "1", "1", "1"],
    ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "1", "1", "1", "0", "1", "1"],
    ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
    ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
    ["0", "1", "1", "1", "1", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
    ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
    ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
    ["1", "1", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1"],
    ["1", "0", "1", "1", "1", "1", "1", "0", "1", "1", "1", "0", "1", "1", "1", "1", "0", "1", "1", "1"],
    ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "1", "1", "1", "1", "1", "0"],
    ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "0", "1", "1", "1", "1", "0", "0"],
    ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
    ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"],
    ["1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1", "1"]
];
console.log(numIslands(grid));